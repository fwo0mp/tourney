#!/usr/bin/env node

import { promises as fs } from 'node:fs';
import path from 'node:path';
import { fileURLToPath } from 'node:url';

const THIS_DIR = path.dirname(fileURLToPath(import.meta.url));
const WEB_ROOT = path.resolve(THIS_DIR, '..');
const CASES_DIR = path.join(WEB_ROOT, 'e2e', 'cases');
const GENERATED_DIR = path.join(WEB_ROOT, 'e2e', 'generated');

const GENERATED_HEADER = `// AUTO-GENERATED FILE. DO NOT EDIT.
// Generated by web/scripts/generate-e2e.mjs.
`;

function quote(value) {
  return JSON.stringify(value);
}

function slugify(value) {
  return value
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, '-')
    .replace(/^-+|-+$/g, '');
}

function extractMachineDefinition(markdown, sourcePath) {
  const jsonBlockMatch = markdown.match(/```json\s*([\s\S]*?)```/i);
  if (!jsonBlockMatch) {
    throw new Error(`missing \`\`\`json block in ${sourcePath}`);
  }

  try {
    return JSON.parse(jsonBlockMatch[1]);
  } catch (error) {
    throw new Error(`invalid JSON machine definition in ${sourcePath}: ${error.message}`);
  }
}

function renderLocator(target) {
  if (!target || typeof target !== 'object') {
    throw new Error(`invalid locator target: ${JSON.stringify(target)}`);
  }

  let locator;
  switch (target.by) {
    case 'testId':
      locator = `page.getByTestId(${quote(target.value)})`;
      break;
    case 'text':
      locator = `page.getByText(${quote(target.value)})`;
      break;
    case 'role':
      locator = `page.getByRole(${quote(target.role)}, { name: ${quote(target.name)} })`;
      break;
    case 'css':
      locator = `page.locator(${quote(target.value)})`;
      break;
    default:
      throw new Error(`unsupported locator strategy: ${target.by}`);
  }

  if (typeof target.nth === 'number') {
    locator = `${locator}.nth(${target.nth})`;
  }
  if (target.first === true) {
    locator = `${locator}.first()`;
  }
  if (target.last === true) {
    locator = `${locator}.last()`;
  }

  return locator;
}

function renderCommand(command) {
  switch (command.type) {
    case 'goto':
      return `await page.goto(${quote(command.path)});`;
    case 'click':
      return `await ${renderLocator(command.target)}.click();`;
    case 'dblclick':
      return `await ${renderLocator(command.target)}.dblclick();`;
    case 'fill':
      return `await ${renderLocator(command.target)}.fill(${quote(command.value)});`;
    case 'select': {
      const locator = renderLocator(command.target);
      if (command.optionLabel !== undefined) {
        return `await ${locator}.selectOption({ label: ${quote(command.optionLabel)} });`;
      }
      if (command.optionValue !== undefined) {
        return `await ${locator}.selectOption(${quote(command.optionValue)});`;
      }
      throw new Error('select command requires optionLabel or optionValue');
    }
    case 'check':
      return `await ${renderLocator(command.target)}.check();`;
    case 'uncheck':
      return `await ${renderLocator(command.target)}.uncheck();`;
    case 'press':
      return `await ${renderLocator(command.target)}.press(${quote(command.key)});`;
    case 'waitForTimeout':
      return `await page.waitForTimeout(${Number(command.ms)});`;
    case 'expectVisible':
      return `await expect(${renderLocator(command.target)}).toBeVisible();`;
    case 'expectHidden':
      return `await expect(${renderLocator(command.target)}).toBeHidden();`;
    case 'expectTextContains':
      return `await expect(${renderLocator(command.target)}).toContainText(${quote(command.value)});`;
    case 'expectTextEquals':
      return `await expect(${renderLocator(command.target)}).toHaveText(${quote(command.value)});`;
    case 'expectValue':
      return `await expect(${renderLocator(command.target)}).toHaveValue(${quote(command.value)});`;
    case 'expectCount':
      return `await expect(${renderLocator(command.target)}).toHaveCount(${Number(command.count)});`;
    case 'expectUrlContains':
      return `await expect(page).toHaveURL(new RegExp(${quote(command.value)}));`;
    case 'expectEnabled':
      return `await expect(${renderLocator(command.target)}).toBeEnabled();`;
    case 'expectDisabled':
      return `await expect(${renderLocator(command.target)}).toBeDisabled();`;
    default:
      throw new Error(`unsupported command type: ${command.type}`);
  }
}

function renderCase(definition, sourceRelPath) {
  if (!definition.id || !definition.title || !Array.isArray(definition.steps)) {
    throw new Error(`machine definition must include id, title, and steps: ${sourceRelPath}`);
  }

  const lines = [];
  lines.push(GENERATED_HEADER.trimEnd());
  lines.push('');
  lines.push(`import { test, expect } from '../fixtures/e2e';`);
  lines.push('');
  lines.push(
    `test(${quote(`${definition.id}: ${definition.title}`)}, async ({ page }) => {`,
  );
  lines.push(`  // Source markdown: ${sourceRelPath}`);
  lines.push('');

  for (const step of definition.steps) {
    if (!step.id || !step.action || !step.expected || !Array.isArray(step.commands)) {
      throw new Error(`invalid step in ${sourceRelPath}: ${JSON.stringify(step)}`);
    }

    lines.push(`  // ${definition.id} ${step.id}: ${step.action}`);
    lines.push(`  // Expected: ${step.expected}`);
    for (const command of step.commands) {
      lines.push(`  ${renderCommand(command)}`);
    }
    lines.push('');
  }

  lines.push('});');
  lines.push('');
  return lines.join('\n');
}

async function clearGeneratedSpecs() {
  await fs.mkdir(GENERATED_DIR, { recursive: true });
  const existing = await fs.readdir(GENERATED_DIR);
  await Promise.all(
    existing
      .filter((entry) => entry.endsWith('.spec.ts'))
      .map((entry) => fs.unlink(path.join(GENERATED_DIR, entry))),
  );
}

async function generate() {
  await clearGeneratedSpecs();
  const entries = (await fs.readdir(CASES_DIR))
    .filter((entry) => entry.endsWith('.md') && entry !== 'README.md')
    .sort((a, b) => a.localeCompare(b));

  if (entries.length === 0) {
    throw new Error(`no markdown cases found in ${CASES_DIR}`);
  }

  const generated = [];
  for (const entry of entries) {
    const sourcePath = path.join(CASES_DIR, entry);
    const sourceRelPath = path.relative(WEB_ROOT, sourcePath);
    const markdown = await fs.readFile(sourcePath, 'utf8');
    const definition = extractMachineDefinition(markdown, sourceRelPath);
    const caseSlug = `${slugify(definition.id)}-${slugify(definition.title)}`;
    const outputPath = path.join(GENERATED_DIR, `${caseSlug}.spec.ts`);
    const content = renderCase(definition, sourceRelPath);
    await fs.writeFile(outputPath, content, 'utf8');
    generated.push(path.relative(WEB_ROOT, outputPath));
  }

  for (const file of generated) {
    console.log(`generated ${file}`);
  }
}

generate().catch((error) => {
  console.error(error.message);
  process.exitCode = 1;
});
